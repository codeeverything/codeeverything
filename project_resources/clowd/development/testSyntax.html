<html><title>DEVELOPMENT VERSION</title>
<body margin="0">
<script src="http://code.jquery.com/jquery-latest.min.js"></script>

<script> var foo = "bar"; //comment </script>


<textarea id="typer" cols="50" rows="20" style="display:none;">
var foo; //boo - something
</textarea>

<!--<img src="mrt.png" style="position:fixed; right:0px; bottom:0px; opacity:0.5;"/>-->

<div id="braces"></div>

<input type="button" id="up" value="UP"/>
<input type="button" id="down" value="DOWN"/>
<input type="button" id="xscroll" value="XSCROLL"/>
<input type="button" id="goto" value="GOTO"/>
<input type="file" id="load" value="Load File"/>
<input type="button" id="rendermode" value="Render Mode"/>

<input type="button" id="includefile" value="Include File"/>

<input type="button" id="find" value="Find"/>

<div id="fileDetail" style="background-color:#111111; color:white;">FILE DETAIL</div>

<canvas width="800" height="800" id="canvas" style="background-color:#ffffff;"></canvas>

<div id="findReplace" style="position:fixed; bottom:0px; background-color:#efefef; border-top:solid black 3px; overflow:auto; height:100px; width: 100%;">

</div>

<textarea id="clipboard" cols="50" rows="20">
</textarea>

<style>
    #contextMenu {background-color:#444444; border:solid 1px yellow; padding:3px;}
    #contextMenu a {display:block; color:#dddddd; text-decoration:none; padding:0px 32px 0px 16px;}
    #contextMenu a:hover {background-color:rgba(200,200,200,0.5);}
</style>

<div id="contextMenu" style="position:absolute;display:none;">
    <a href="">Cut</a>
    <a href="">Copy</a>
    <a href="">Paste</a>
    <a href="" id="selectAll">Select All</a>
    
    <hr/>
    
    <span style="color:#dddddd;">Paste Board</span><br/>
    <a href="">#1: $bob = "var"...</a>
    <a href="">#2: function foo()...</a>
    <a href="">#3: var a = b?b:c;...var c = true;</a>
    
    <hr/>
    
    <a href="" id="toggleComment">Toggle Comment</a>
    <a href="" id="toggleComment">Describe this Variable</a>
    
    <hr/>
    
    <a href="">Add TODO</a>
    <a href="">Add Unit Test</a>
    
    <hr/>
    
    <a href="">Export to External File</a>
</div>

<style>    .file, .dir {color:white;}
</style>
<div id="filepanel" style="position:fixed; right:0px; top:0px; padding:10px; background-color:#111111; overflow:hidden"></div>




<script src="syntax/htmlparse.js"></script>
<script src="syntax.js"></script>
<script src="syntax/jsparse.js"></script>
<script>

  
var includeDocLines = false;

var currentFilename = '';

$(document).ready(function() {
    
    $.get('listFiles.php', {}, function(filelist) {
        //alert(filelist);
        $('#filepanel').html(filelist);
    });
    
    $('#filepanel').click(function() {
        if($(this).height() > 20) {
            $(this).height("20px");
        } else {
            $(this).animate({height:'100%'}, "slow");
        }
    });
    
    $('.file').live('click', function() {
        var fname = $(this).attr('href');
        $.get('loadFile.php', {name: fname}, function(file) {
            //alert('done');
           
            currentFilename = fname;
            lines = file.split("\n");
            for(var i=0;i<lines.length;i++) {
                lines[i] = lines[i].replace(/\t/g, '    ');
            }
            
            //console.log(lines); 
            
            render(true);
        });    
        
        return false;
    });
    
    $('.dir').live('click', function() {
        $.get('listFiles.php', {path:$(this).attr('href')}, function(files) {
            //alert(files);
            $('#filepanel').html(files)
        });
        
        return false;
    });
   
    /*
    $.get('document.js', {}, function(file) {
        lines = file.split("\n");
        for(var i=0;i<lines.length;i++) {
            lines[i] = lines[i].replace(/\t/g, '    ');
        }
        render();
        
    });*/
    
    $('#includefile').click(function() {
        if(!includeDocLines) {
            $.get('syntax/jsparse.js', {}, function(file) {
                var newLines = file.split("\r\n");
                for(var i=0; i<newLines.length;i++) {
                    lines.splice(i+10, 0, "      "+newLines[i].replace(/\t/g, '    '));
                }

                
                includeDocLines = {start: 10, end: 10+newLines.length-1};
                render(true);
            });
        } else {
            lines.splice(includeDocLines.start, (includeDocLines.end - includeDocLines.start)+1);
            includeDocLines = false;
            render(true);
        }
    });
    
    $('#selectAll').click(function() {
        selection = {x1:0, y1:0, x2: lines[lines.length-1].length, y2: lines.length-1};
        render(true);
        return false;
    });
    
    $('#toggleComment').click(function() {
        for(var i=selection.y1;i<=selection.y2;i++) {
            dirty[i] = true;
            lines[i] = insertChar('//',0, lines[i]);
        }
        render();
        return false;
    });
    
});

var canvas = document.getElementById('canvas');
canvas.width = window.innerWidth-20;
var context = canvas.getContext("2d");
context.textBaseline = "top";
context.font = "11pt monospace";
context.clearRect(0,0,800,window.innerWidth-20);


var dirty = {};
var offset = 0;
var lines = [];    //may make this an array of objects {text: '', indent: X, dirty: true}, or something
var cursorPos = [0,0];
var charPos = [0,0];

var selection = false;

var find = false;

//this will be set in some class var
var mwidth = context.measureText('m').width;

var  gotoLine = 0;

var cachedRegions = [];

var renderMode = true;

var insertOn = false;

//an array of characters/inputs that will trigger an undo item to be created
//might include stopChars for the current language, and perhaps a timed trigger
//perhaps as people type we'll store each action in a stack and then when an action doesn't match the ones before we "flush"
//the stack into an undo item
//we would also do this when a trigger was reached
var undoTriggers = [];


var translate = 0;

var saveFile = function() {
    var file = lines.join("\n");
    $.post('saveFile.php', {name: currentFilename, file: file}, function(file) {
        alert('saved '+file);
        //render(true);
    });
}    

var insertChar = function(ch, pos, str) {
    //return str.substring(0, pos)+ch+str.substring(pos);
    
        var removeCount = insertOn ? 1:0;
        var strA = str.split('');
        //console.log(strA);
        strA.splice(pos, removeCount, ch);
        return strA.join('');
}

//removes a character from the string at the given position
var deleteChar = function(pos, str) {
        var strA = str.split('');
        strA.splice(pos, 1);
        return strA.join('');
}

//splits a line in two at pos. returns an array of the two lines
var splitLine = function(line, pos) {
    //console.log(line.match(/^\s+/g)[0]);
    //tab indent - sort of!
    var tabOffset = 0;
    try {
        if(line.match(/^\s+/g).length > 0) {
            tabOffset = line.match(/^\s+/g)[0];
        }
    } catch(e) {}
    
    return [line.substring(0, pos), tabOffset+line.substring(pos)];
}
        
//create a new blank line at position
var addLine = function(pos, line) {
        lines.splice(pos, 0, line);
}

//remove a whole line at position
var removeLine = function(pos) {
        lines.splice(pos, 1);
}

var joinLine = function(line1, line2) {
    //console.log(line1 +''+ line2);
        return line1 +''+ line2;
}

var clearSelection = function() {
    if(!selection || !selection.x2) return;
    
    console.log(selection);
    selection = false;
    render(true);    //a full refresh will clear the selection
    //but a better approach would be to mark the lines in the selection as dirty!
}

var getSelectedText = function() {
    //pass in selection?
    //dunno
    
    //same line selection
    if(selection.y1 == selection.y2) return lines[selection.y1].substring(selection.x1, selection.x2);
    
    console.log(selection);
    
    //multi-line
    //treat the first and last lines as a special case
    var firstLine = lines[selection.y1].substring(selection.x1);
    var lastLine = lines[selection.y2].substring(0, selection.x2);
    
    var selectedText = '';
    for(var i=selection.y1+1; i<selection.y2; i++) {
        selectedText += lines[i]+"\n";
    }
    
    return firstLine+"\n"+selectedText+"\n"+lastLine;
}
//check out this link for details on copy and paste: http://www.geekpedia.com/tutorial126_Clipboard-cut-copy-and-paste-with-JavaScript.html
var copyText = function() {
    var clipboard = document.getElementById('clipboard');
    var text = getSelectedText();
    clipboard.value = text;
    
    clipboard.focus();
    clipboard.select(); 
    
    CopiedTxt = document.selection.createRange();
    
    CopiedTxt.execCommand("Copy");
}

var copyTextAppend = function() {}

var pasteText = function() {
    var text = document.getElementById('clipboard').value.replace(/\t/g, '    ');
    //var text = 'test test test';
    
    var textLines = text.split("\n");
    
    lines[charPos[1]] = insertChar(textLines[0], charPos[0], lines[charPos[1]]);
    
    if(textLines.length > 1) {
        var newLines = splitLine(lines[charPos[1]], charPos[0]+textLines[0].length);
        lines[charPos[1]] = newLines[0];
        addLine(charPos[1]+1, newLines[1]);
        
        for(var i=1; i<textLines.length; i++) {
            addLine(charPos[1]+i, textLines[i]);
        }
        
    }
    
    console.log(lines[charPos[1]]);
    
    dirty[charPos[1]] = true;
    render(true);
}

var cutText = function() {
    //basicaly a copy followed by a deletion
    copyText();
    deleteChunk(selection);
}

var loadDocument = function(file) {
    $.get(file, {}, function(file) {
        lines = file.split("\r\n");
        cachedRegions = false;
        dirty = [];
        render(true);
    });
}

var jumpToLine = function(line) {
    gotoLine = line;
    
    //if the goto line is off the current viewable area (up or down) then reset the offset
    if(line > offset + 25 || line < offset - 25 )
        offset = line;

    charPos = [0, line];
    render(true);
}

var dblClickSelectText = function(pos) {
    //pos is the charPos of the double click
    //read backward until we find a stopChar and log that as the start of the selection
    //read forward until we find a stopChar and log as the end
    //render that line again
}


var addEditItem = function(item) {

    /*
    the aim of this function is to add to a list of edits that have been performed on this file
    communicating these to the back-end to update the copy of the file there, which in turn may update another
    client if collaboratibe editing is taking place
    
    so, this has be to be lightweight, as the edits should be viewable in real-time (but only if the document is 
    being edited collaboratively
    
    we can build a list of actions that have been performed (like the undo list), but reduce the size of this by
    adding edits that are the same together
    
    for example: if i start adding text as position X then each keystroke will generate an insertChar item
    because each subsequent item will have the same start coords i can simple add this new char to this item rather than
    create a whole new one.  so, insertChar(0,0,'a') becomes insertChar(0,0,'ab') and so on
    
    for the insert char case if the character is the same then we can reduce things further by defining a number of times to
    complete this action. for example: insertChar(0,0,'a',10)
    
    for this simple case we can therefore reduce the amount of information to be sent to the server to complete the update
    
    
    */

}



document.getElementById('up').onclick = function() {
    offset++;
    render();
}

document.getElementById('down').onclick = function() {
    offset--;
    render();
}

document.getElementById('goto').onclick = function() {
    gotoLine = prompt('Goto Line');
    jumpToLine(gotoLine);
}

document.getElementById('load').onclick = function() {
    //var file = prompt('what file you wanna open?');
    //loadDocument(file);
}

document.getElementById('load').onchange = function() {
    console.log(this.value);
    loadDocument(this.value);
}

document.getElementById('rendermode').onclick = function() {
    renderMode = !renderMode;
    render(true);
}

document.getElementById('xscroll').onclick = function() {
    context.translate(translate - mwidth, 0);
    render();
}



var findstr = function(str) {
    var matches = [];
    var i = lines.length;
    var localFind = {matches: []};
    var found = '';
    
    //for(var i=0; i<len; i++) {
    for(;i--;) {
        
        var idx = -1;
        var count = 0;
        
        idx = lines[i].indexOf(str);
        if(idx != -1) {
            found += "Found match on line "+i+", char "+idx+"<br/>";     //matches[i].push(idx);
            
            if(!localFind.matches[i]) {
                //console.log('logging a find on line '+i);
                localFind.matches[i] = [];
            }
            localFind.matches[i].push({x1: idx+1, x2: idx+str.length+1});
        
            while(idx != -1) {
                idx = lines[i].indexOf(str, idx+str.length);
                if(idx != -1) {
                    found += "Found match on line "+i+", char "+idx+"<br/>";     //matches[i].push(idx);
                    
                    if(!localFind.matches[i]) {
                        //console.log('logging a find on line '+i);
                        localFind.matches[i] = [];
                    }
                    
                    localFind.matches[i].push({x1: idx+1, x2: idx+str.length+1});
                }
                
                count++;
                if(count > 10) { console.log('breaking on count'); break; }
            }
        }
    }
    
    find.matches = localFind.matches;
    
    document.getElementById('findReplace').innerHTML = found;
}

document.getElementById('find').onclick = function() {
    $('#findReplace').hide();
    var str = prompt('What are you looking for?');
    
    $('#findReplace').css({height:"0px", opacity:0}).animate({height: "200px", opacity:1}, 1000);
    
    document.getElementById('findReplace').innerHTML = '';
    
    find = {y1: 0, y2: lines.length, matches: []};
    
    
    
    findstr(str);
    
    //console.log(find);
    render();
}

var mousedown = false;

canvas.onmousedown = function(e) {
    mousedown = true;
    
    
    
    //clear the current selection
    if(selection && !e.shiftKey) clearSelection();
    //well. not quite
    //we don't want to clear the selection if we're dragging it elsewhere
    //this catch will need to be in onmousedown
    //if(within(pos, selection) handle dragging the selected text
    
    //get the details of where the client clicked in the canvas
    var x = e.clientX - document.getElementById('canvas').offsetLeft;
    var y = e.clientY - document.getElementById('canvas').offsetTop;

    //this is our initial guess at the line they clicked on
    var line = y/18;
    
    //get an int value
    line = parseInt(line);
    if(line < 0) line = 0;    //fix if we're under 0 for some reason
    
    //the initial guess isn't necessarily accurate enough
    //so lets figure out the extent of the guessed line
    var lineMin = (18*line);
    var lineMax = (18*line)+18;
    
    //if the click we above the guess lines extent, it was on the line above. otherwise it was the line below
    if(y < lineMin) line--;
    else if(y > lineMax) line++;
    
    //adjust for the current offset
    renderLine = line;    //we use this to get a canvas position to render the cursor to, no matter what the offset
    line+=offset;
    
    
    gotoLine = line;
    
    dirty[line] = true;
    dirty[charPos[1]] = true;
    
    //if(includeDocLines)
    render(includeDocLines);
    
    
        
    //console.log('Line '+(line)+':'+lines[line]);
    
    // BELOW SHOULD BE A drawCursor FUNCTION IN A CURSOR CLASS
    
    //clear the existing cursor
    context.clearRect((charPos[0]+1)*mwidth, charPos[1]*18, 1, 18);
    
    
    //console.log(mwidth);
    
    //the +10 in the calcs below if the left margin. this should be in some class var as well (editor/renderer?)
    //console.log(lines[line].length);
    var lineLen = lines[line].length;
    var maxCharPos = mwidth * lineLen;
    maxCharPos += 10;
    
    //console.log('Are we beyond the end of the line?: '+x+' > '+maxCharPos);
    if(x > maxCharPos) {
        var xpos = maxCharPos;
        context.fillStyle = '#06ACC2';
        context.fillRect(xpos, 18*renderLine, 1, 18);
        cursorPos = [xpos, 18*renderLine];
        
        c = lineLen+1;
    } else {
        for(var c=0; c<=lines[line].length+1; c++) {
            if((mwidth*c)+10 > x) {
                var xpos = (mwidth*(c-1))+10;
                context.fillStyle = '#06ACC2';
                context.fillRect(xpos, 18*renderLine, 1, 18);
                cursorPos = [xpos, 18*renderLine];

                break;
            }
        }
    }
    
    selection.x1 = c-1;
    
    charPosOld = charPos;
    charPos = [c-1, line];
    
    //selection = {x1:0, y1:0};
    if(!selection) {
        selection = {x1:charPos[0], y1: charPos[1]};
    }
}

canvas.onmousemove = function(e) {
    if(mousedown) {
        //console.log('dragging');
        //selection.x2 = e.clientX/mwidth;
        //selection.y2 = (e.clientY/18)-1;
        //get the details of where the client clicked in the canvas
        var x = e.clientX - document.getElementById('canvas').offsetLeft;
        var y = e.clientY - document.getElementById('canvas').offsetTop;
    
        //this is our initial guess at the line they clicked on
        var line = y/18;
        
        //get an int value
        line = parseInt(line);
        if(line < 0) line = 0;    //fix if we're under 0 for some reason
        
        //the initial guess isn't necessarily accurate enough
        //so lets figure out the extent of the guessed line
        var lineMin = (18*line);
        var lineMax = (18*line)+18;
        
        //if the click we above the guess lines extent, it was on the line above. otherwise it was the line below
        if(y < lineMin) line--;
        else if(y > lineMax) line++;
        
        //adjust for the current offset
        renderLine = line;    //we use this to get a canvas position to render the cursor to, no matter what the offset
        line+=offset;
        
        
        gotoLine = line;
        
        dirty[line] = true;
        dirty[charPos[1]] = true;
        
        //if(includeDocLines)
        render(includeDocLines);
        
        
            
        //console.log('Line '+(line)+':'+lines[line]);
        
        // BELOW SHOULD BE A drawCursor FUNCTION IN A CURSOR CLASS
        
        //clear the existing cursor
        context.clearRect((charPos[0]+1)*mwidth, charPos[1]*18, 1, 18);
        
        
        //console.log(mwidth);
        
        //the +10 in the calcs below if the left margin. this should be in some class var as well (editor/renderer?)
        //console.log(lines[line].length);
        var lineLen = lines[line].length;
        var maxCharPos = mwidth * lineLen;
        maxCharPos += 10;
        
        //console.log('Are we beyond the end of the line?: '+x+' > '+maxCharPos);
        if(x > maxCharPos) {
            var xpos = maxCharPos;
            context.fillStyle = '#06ACC2';
            context.fillRect(xpos, 18*renderLine, 1, 18);
            cursorPos = [xpos, 18*renderLine];
            
            c = lineLen+1;
        } else {
            for(var c=0; c<=lines[line].length+1; c++) {
                if((mwidth*c)+10 > x) {
                    var xpos = (mwidth*(c-1))+10;
                    context.fillStyle = '#06ACC2';
                    context.fillRect(xpos, 18*renderLine, 1, 18);
                    cursorPos = [xpos, 18*renderLine];
    
                    break;
                }
            }
        }
        
        //selection.x1 = c-1;
        
        charPosOld = charPos;
        charPos = [c-1, line];
        
        
        selection.x2 = c-1;
        selection.y2 = line;
        
        console.log(selection);
        
        //if we're at the bttom (need top check too), then scroll the text
        //if(e.clientY/18 >= 45) offset++;
        //we'll need an interval here which will check if the position is still outside the area
        //if it is keep scrolling!
        
        //rather than do a full refresh we could dirty up only those lines that have been added to/removed from
        //the selection since the last render.  
        //for example: lastY = selection.y2, if curline > lastY, dirtyp[curline]
        render(true);
    }
}

canvas.onmouseup = function(e) {
    //console.log('mouseup at '+e.clientX+','+e.clientY);
    mousedown = false;
    //clear any scrolling check interval here
}

//keydown captures some keys
document.onkeydown = function(e) {
    console.log(e.which);
    
    //clear the current selection
    if(!e.shiftKey && !e.ctrlKey) clearSelection();
    
    if(e.ctrlKey) {
        if(e.which == 67) { copyText(); }
        if(e.which == 88) alert('cut');
        if(e.which == 86) { pasteText(); };
        
        //ctrl F
        if(e.which == 70) { document.getElementById('find').onclick(); }
        //return false;
        
        //ctrl s - save
        if(e.which == 83) { saveFile(); return false; }
    }
    
    
    //page up
    if(e.which == 33) {
        offset-=40;
        render(true);
        return false;
    } 
    
    //page down
    if(e.which == 34) {
        offset+=40;
        render(true);
        return false;
    } 
    
    //home
    //end
    if(e.which == 36 || e.which == 35) {
    
        if(e.shiftKey) {
            if(e.which == 36) selection = {x1: 0, y1: charPos[1], x2: charPos[0], y2: charPos[1]};
            else selection = {x1: charPos[0], y1: charPos[1], x2: lines[charPos[1]].length, y2: charPos[1]};
        }
        
        //quick jump to the top or bottom of the document
        if(e.ctrlKey) {
            offset = e.which == 36 ? 0:(lines.length - 45);
            charPos = e.which == 36 ? [0,0]:[lines[lines.length-1].length, lines.length];
                    render(true);
        } else {
            //jump to the start or end of the current line
            charPos[0] = e.which == 36 ? 0:lines[charPos[1]].length;
            dirty[charPos[1]] = true;
            render();
        }
        
        return false;
    }
    
    //insert?
    if(e.which == 45) {
        //set a flag so we know to replace chars when doing an insertChar rather than just insert one
        insertOn = !insertOn;
    }
    
    //arrow keys
    
    //backspace and delete
    if(e.which == 8 || e.which == 46) {
        //make this more robust!
        //if we hit backspace at the beginning of a line join it with the line above
        //also need to check for delete at the end of the line, joining with the line below
        if(charPos[0] <= 0 && e.which == 8) {
            var newX = lines[charPos[1]-1].length;
            lines[charPos[1]-1] = joinLine(lines[charPos[1]-1], lines[charPos[1]]);
            removeLine(charPos[1]);
            
            dirty[charPos[1]-1] = true;
            //we'll need to render every line after this one!
            //well not quite. we need to render every visdible line sfter this one
            //much better!
            for(var i=charPos[1]-1;i<charPos[1]+45;i++) dirty[i] = true;
            //this should be a call to updateCursor or something that will redraw the cursor and update the charPos
            charPos = [newX, charPos[1]-1];
        } else {
            if(charPos[0] == lines[charPos[1]].length && e.which == 46) {
                
                if(selection.x2) {
                    deleteChunk(selection);
                } else {
            
                    var newX = lines[charPos[1]].length;
                    lines[charPos[1]] = joinLine(lines[charPos[1]], lines[charPos[1]+1]);
                    removeLine(charPos[1]+1);
                    
                    dirty[charPos[1]] = true;
                    charPos = [newX, charPos[1]];
                    
                }    
            } else {
                var pos = e.which == 8 ? charPos[0]-1:charPos[0];
                lines[charPos[1]] = deleteChar(pos, lines[charPos[1]]);
                //this should be a call to retreatCursor or something that will redraw the cursor and update the charPos
                if(e.which == 8) charPos[0]--;
            }
        }
        
        dirty[charPos[1]] = true;
        
        render();
        return false;
    }
    
    //tab
    if(e.which == 9) {
        var newX = charPos[0]+4;
        lines[charPos[1]] = insertChar('    ', charPos[0], lines[charPos[1]]);

        dirty[charPos[1]] = true;
        //this should be a call to updateCursor or something that will redraw the cursor and update the charPos
        charPos = [newX, charPos[1]];
        
        render();
        return false;
    }
    
    //left and right
    if(e.which == 37 || e.which == 39) {
        
        if(!selection) selection = {x1: charPos[0], x2: charPos[0], y1: charPos[1], y2: charPos[1]};

        
                
        dirty[charPos[1]] = true;
        
        //update the cursor position
        charPos[0] += e.which == 37 ? -1:1;
        if(charPos[0] > lines[charPos[1]].length) {
            charPos[0] = 0;
            charPos[1]++;
        } else if(charPos[0] < 0) {
            charPos[0] = lines[charPos[1]-1].length;
            charPos[1]--;
        }
        
        if(e.shiftKey) {
            if(!selection.y2) selection.y2 = charPos[1];
            selection.x2 = charPos[0];
            console.log(selection);
            dirty[charPos[1]] = true;
        } else {
            clearSelection();
        }
        
        
        
        render();
        return false;
    }
    
    
    //up and down
    if(e.which == 38 || e.which == 40) {
    
        dirty[charPos[1]] = true;
        
        if(e.shiftKey) {
            charSelection = {x1: selection.x1, x2: selection.x1+1};            
        }
        
        //update the cursor position
        charPos[1] += e.which == 38 ? -1:1;
        if(charPos[0] > lines[charPos[1]].length) charPos[0] = lines[charPos[1]].length;
        
        dirty[charPos[1]] = true;
        
        render();
        return false;
    }
    
    
}

//keypress captures the rest
document.onkeypress = function(e) {
    //console.log(e.which);
    //console.log(e);
    if(e.ctrlKey) {
        if(e.which == 26 && e.shiftKey) alert('redo');
        else if(e.which == 26) alert('undo');
        
        return false;
    }
    
    //enter
    if(e.which == 13) {
    
    
        var newLines = splitLine(lines[charPos[1]], charPos[0]);
        lines[charPos[1]] = newLines[0];
        addLine(charPos[1]+1, newLines[1]);
        
        console.log(newLines);

        //move the character pointer to the start of the new line
        if(newLines[1].match(/^\s+/g)) {
            var xpos = newLines[1].match(/^\s+/g)[0].length ? newLines[1].match(/^\s+/g)[0].length:0;
        } else {
            var xpos = 0;
        }
        
        
        charPos = [xpos, charPos[1]+1];    //this should be a call to updateCursor or something that will redraw the cursor and update the charPos
        
        //we'll need to render every line after this one!
        //well not quite. we need to render every visdible line sfter this one
        //much better!
        //the loop below is not quite right as +45 is the max lines, but there may only be one line after this one
        for(var i=charPos[1]-1;i<charPos[1]+45;i++) dirty[i] = true;
        
        //console.log('marking lines '+charPos[1]+' to '+(charPos[1]+45)+' as dirty');
        render(true);    //rendering a full refresh for now to make things easier to work with.
        //but this shouldn't be necessary. same bug occurs for deleting lines, AND ONLY WHEN WE HAVE AN OFFSET...
    } else {
        //make this more robust!
        lines[charPos[1]] = insertChar(String.fromCharCode(e.which), charPos[0], lines[charPos[1]]);
        
        //this should be a call to advanceCursor or something that will redraw the cursor and update the charPos
        charPos[0]++;
    }

    //hacked attempt at scrolling on the X axis when we exceed the size of the canvas
    //needs to scroll back to 0 as well, and take into account any Y offset rather than hardcode 0
    //if(charPos[0] > 20) context.translate(translate - mwidth, 0);

    dirty[charPos[1]] = true;
    render();    
    return false;
}

document.getElementById('canvas').onmousewheel = function(e) {
        var delta=e.detail? e.detail*(-120) : e.wheelDelta; //check for detail first so Opera uses that instead of wheelDelta

    if(delta > 0) {
            offset-=5;
        } else {
            offset+=5;
        }
        
        render(true);
        return false;
}
    
canvas.oncontextmenu = function(e) {
    $('#contextMenu').css('top', e.y).css('left', e.x).show();
    
    return false;
}

document.getElementById('canvas').onclick = function(e) {
    //console.log(e);
    //hide the context menu
    $('#contextMenu').hide();
    
    
    
    
    
    if(e.shiftKey) {
        //console.log('Selection runs from line '+charPosOld[1]+', char '+charPosOld[0]+' to line '+charPos[1]+', char '+charPos[0]);
        console.log(selection);
        if(!selection) {
            console.log(' no selection');
            selection = {x1: charPosOld[0]+1, y1: charPosOld[1], x2: charPos[0], y2: charPos[1]};
        } else {
            // adding to an existing selection
            var s = selection;
            selection = {x1: s.x1, y1: s.y1, x2: charPos[0], y2: charPos[1]};
        }
        
        //console.log(getSelectedText().split("\n"));
        
        render();
    }
    
    /*
    this is a pretty naive implementation of an ad hoc brace matching algorithm
    would be better to check the line using indexof for a brace, before checking each char
    i'm sure there are other optimizations and these braces should be picked up in parsing with locations updated during
    editing really
    */
    /*
    if we can effciently reverse each line we can do indexOf matches to effectively look backward along each line
    counting open/close brackets as we go.
    this is the same spirit as looking at each char, but hopefully offloads more of the legwork into the JS engine
    ????
    
    for(;line>=0;line--) {
        var f = reverse(lines[line]);
        
        var closeCount = 0;
        var openCount = 0;
        var counter = 0;
        var idx = 0;
        
        //console.log(f+" :: F LENGTH: "+f.length);
        
        while(idx !== -1) {
            if(counter > 10) return;
            counter++;
            
            idx = f.indexOf('}', idx);
            if(idx != -1) {
                //console.log('} at pos '+idx);
                closeCount++;
                idx++;
                if(idx == f.length) break;
                if(openCount == closeCount) {
                    //console.log('found match on line '+lines[line]);
                    return;
                }
                continue;
            }
            
            idx = f.indexOf('{', idx);
            if(idx != -1) {
                //console.log('{ at pos '+idx);
                openCount++;
                idx++;
                if(idx == f.length) break;
                if(openCount == closeCount) {
                    //console.log('found match on line '+lines[line]);
                    return;
                }
                continue;
            }
        }
        
        
        //console.log(reverse(lines[line]));
    }*/
    
    return;
    
    if(lines[line].charAt(charPos[0]-1) == '}') {
        
    
        console.log('Found a closing brace on line '+line+', char '+charPos[0]+' looking for opener');
        var closeCount = 0;
        var openCount = 0;

        //current line special case - rubbish :)
        var hackedLine = lines[line].replace(/[^\{\}]/g, '');
        console.log("Hacked line: "+hackedLine);
        //var startPos = charPos[0]-1;
        var startPos = hackedLine.length;
        for(var i=startPos;i>=0;i--) {    
            //var ch = lines[line].charAt(i);
            var ch = hackedLine.charAt(i);
            console.log('checking char '+ch);
            if(i == 0 && ch != '{') {
                if(line == 0) { console.log('couldnt find matching open bracket'); return; }
                //we've exhausted this line
                line--;
                break;
            }
            
            if(ch == '{') openCount++;
            if(ch == '}') closeCount++;
            
            if(openCount == closeCount) {
                console.log('Found the opener on line '+line+':'+lines[line]);
                $('#braces').html('This brace closes the opener on this <a href="" onclick="jumpToLine('+line+'); return false;">line '+line+'</a> [<b>'+lines[line]+'</b>] at pos '+i);
                return;
            }
        }

        for(;line>=0;line--) {
            //if the line has no open or close braces move onto the next one
            if(lines[line].indexOf('{') == -1 && lines[line].indexOf('}') == -1) continue;

            var hackedLine = lines[line].replace(/[^\{\}]/g, '');
            console.log("Hacked line: "+hackedLine);
        
            //for(var i=lines[line].length;i>=0;i--) {    
            for(var i=hackedLine.length;i>=0;i--) {    
                //var ch = lines[line].charAt(i);
                var ch = hackedLine.charAt(i);
                console.log('checking char '+ch);
                if(i == 0 && ch != '{') {
                    if(line == 0) { console.log('couldnt find matching open bracket'); return; }
                    //we've exhausted this line
                    break;
                }
                
                if(ch == '{') openCount++;
                if(ch == '}') closeCount++;
                
                if(openCount == closeCount) {
                    console.log('Found the opener on line '+line+':'+lines[line]);
                    $('#braces').html('This brace closes the opener on this <a href="" onclick="jumpToLine('+line+'); return false;">line '+line+'</a> [<b>'+lines[line]+'</b>] at pos '+i);
                    return;
                }
            }
        }
            
    }
}

function reverse(str) {
        return str.split('').reverse().join('');
    }
    
    
function render(full) {
    //console.log(render.caller);
    var syntax = new Syntax();
    
    /*
    // Build a worker
    var worker = new Worker("testworker.js");
    
    // Listen for incoming messages
    worker.onmessage = function(e){
        alert(e.data.code);
        console.log(e.data.other);
    };   
    
    // Start the worker
    worker.postMessage( {code:"var foo = false; //a test line of code", other:[true, false, true]} );
    */
        
    if(lines.length <= 0) lines = document.getElementById('typer').value.split("\n");
    var len = lines.length;
    var maxLines = 45;
    var y = offset;
    var maxLine = y+maxLines
    //if(maxLine > len) maxLine = len;
        
    //quick check to see if we should just not do anything
    if(offset < 0 || ((len-maxLines) > 0 && offset > (len-maxLines))) { offset = offset < 0 ? 0:(len-maxLines); return; }

    //only do this is we're doing a full refresh
    if(full) context.clearRect(0,0,canvas.width,800);
    
    //console.log(cachedRegions);

    //console.log(selection);
    
    var fillCount = 0;
    
    for(; y<maxLine;y++) {
        var text = lines[y];
        
        if(!cachedRegions[y]) {
            syntax.clearRegions();
            syntax.JS(text);
            var regions = syntax.getRegions();
            cachedRegions[y] = regions;
            //console.log(regions);
        } else {
            //if the line hasn't changed don't bother re-rendering it
            //console.log(dirty);
            if(!dirty[y] && !full) continue;
            //var regions = cachedRegions[y];
            syntax.clearRegions();
            syntax.JS(text);
            var regions = syntax.getRegions();
            cachedRegions[y] = regions;
            console.log('rendering line: '+y);
        }
        
        context.clearRect(0,18*y,canvas.width,18);
        
        //console.log(regions);
        
        if(y==gotoLine) {
            context.fillStyle = '#E5EECC';
            context.fillRect(0, 18*(y-offset), canvas.width, 18);
            
            
        } 
        
        /*
        //experimenting with hightlighting certain areas of text
        if(y >= charPos[1] - 2 && y <= charPos[1] + 2) {
            context.globalAlpha = 1;
        } else {
            context.globalAlpha = 0.5;        
        }
        */
        
        /*if(charPos && y==charPos[1]) {
            context.fillStyle = '#444444';
            context.fillRect(0, 18*(y-offset), canvas.width, 18);
        }*/
        
        //SELECTIONS
        var yLow = selection.y2 > selection.y1 ? selection.y1:selection.y2;
        var yHigh = selection.y2 > selection.y1 ? selection.y2:selection.y1;
        
        //yHigh -= 2;
        if(selection && y >= yLow && y <= yHigh) {
            var x = 0;
            if(y == selection.y1 ) {
                x = (selection.x1+1)*mwidth;
            }
            
            //var w = selection.x2 < lines[y].length ? selection.x2*mwidth:lines[y].length*mwidth;
            var w = y != yHigh ? lines[y].length*mwidth:(selection.x2)*mwidth;
            
            context.fillStyle = '#9DBFD1';
            context.fillRect(x, 18*(y-offset), w, 18);
        }
        
        //FIND MATCHES
        var yLow = find.y1;
        var yHigh = find.y2;
            
        if(find.matches && y >= yLow && y <= yHigh) {
            var localMatches = find.matches;
            
            context.globalAlpha = 0.5;
            var x = 10;
            if(localMatches[y]) {
                for(var j=0; j<localMatches[y].length; j++) {
                    x1 = localMatches[y][j].x1*mwidth;
                    x2 = localMatches[y][j].x2*mwidth;
                    
                    var w = x2 - x1;
                    
                    context.fillStyle = '#3333aa';
                    context.fillRect(x1, 18*(y-offset), w, 18);
                }
            }
            
            context.globalAlpha = 1;
        }
        
        //INLINE EXTERNAL DOCUMENTS
        if(y >= includeDocLines.start && y <= includeDocLines.end) {
            if(charPos[1] >= includeDocLines.start && charPos[1] <= includeDocLines.end) { 
                context.globalAlpha = 1;
            } else {
                context.globalAlpha = 0.5;
            }
            
            context.fillStyle = 'rgba(100,200,200,0.35)';
            context.fillRect(10, 18*(y-offset), canvas.width, 18);
        } else {
            if(charPos[1] >= includeDocLines.start && charPos[1] <= includeDocLines.end) { 
                context.globalAlpha = 0.5;
            } else {
                context.globalAlpha = 1;
            }
        }
        
        //to reduce any complexity in selections we could simply render selected lines as white text
        //this would mean quicker rendering when selecting, which would free up time to do other stuff
        
        //just plain white. or syntax highlighted
        if(!renderMode) {
            context.fillStyle = '#000000';
            
            //for testing editing lets do a really simple render. just output the whole line in white
            context.fillText(text, 10, 18*(y-offset));
        } else {
            
            
            for(var style in regions) {
                if (!regions.hasOwnProperty(style)) continue;
                
                //console.log(regions);
                
                var line = '';
                var cPos = 0;
                var thisRegion = regions[style];
                for(var sr=0; sr<thisRegion.length; sr++) {
                    for(;cPos<regions[style][sr].spos; cPos++) line += ' ';
                    //console.log(text.substring(thisRegion[sr].spos, thisRegion[sr].epos));
                    line += text.substring(regions[style][sr].spos, regions[style][sr].epos);
                    cPos = regions[style][sr].epos;
                }
                
                //console.log(line);
                
                context.fillStyle = style;
                context.fillText(line, 10, 18*(y-offset));
                fillCount++;
            }
            
            
            
        }
    }
    
    console.log('fillText count: '+fillCount);
    
    //once we've drawn things, nothing should be dirty. for a few milliseconds anyway!
    dirty = {};
    
    //render the cursor
    context.fillStyle = '#06ACC2';
    context.fillRect((charPos[0]+1)*mwidth, 18*charPos[1], 1, 18);
    
    //update file details
    document.getElementById('fileDetail').innerHTML = "Lines: "+lines.length+", Position: "+charPos[1]+","+charPos[0];
}



//console.log(charPos);
</script>

</body>
</html>